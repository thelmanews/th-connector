<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-selector/core-selector.html">

<link rel="import" href="../juicy-tile-list/src/juicy-tile-list.html">

<link rel="import" href="../core-collapse/core-collapse.html">
<link rel="import" href="../core-icon-button/core-icon-button.html">
<link rel="import" href="../th-theme/th-theme.html">






<polymer-element name="th-connector" extend="d3-chart" attributes="">
  <core-style ref="theme"></theme>
  <template>
    <style>
      :host{
        font-size: 12px;
        font-family: open-sans, sans-serif;

      } 
      #chartData_anchor1 {
        position: absolute;
        top: 5px;
        left: 5px;
      }
      #chartData_anchor2 {
        position: absolute;
        top: 25px;
        left: 5px;
      }
      .anchor {
        width: 5px;
        height: 5px;
        background-color: #555;
        cursor: pointer;
      }
      .item {
        width: 100%;
        border-bottom: 1px solid #555;
        line-height: 1.4em;

      }
      .panel {
        border: 1px solid #AAA;
        background-color: rgba(255,255,255,0.9);
        padding: 5px;
        margin: 10px;
        position: relative;
        width: 900px;
        z-index: 110;

      }
      .panel .selector {
        display: inline;
        margin-right: 10px; 

      }
      .panel core-selector {
        width: 150px;
        display: inline-block;
        vertical-align: top;
      }
      .panel .core-selected {
        background-color: #ccc;
        border: 1px solid #888;
      }
      .panel label {
        display: inline-block;
        vertical-align: top;
      }
      .connections {
        margin-top: 10px;
      }

      .connections ul {
        list-style: none;
        width: 80%;
        padding: 0;
        margin: 0;
      }
      .connections ul li {
        margin: 3px 0;
      }
      .connections .del {
        float: right;
        color: #2fa3af;
      }

      .panel #connect {

        display: none;
        position: absolute;
        top: 0;
        right: 0;
        background-color: #2fa3af;
        color: #EEE;
        border: 1px solid #AAA;

      }

      a, a:visited {
        color: #555;
        text-decoration: none;
      }

      .panel h3 {
        font-family: arial;
        margin: 5px 0px;
        font-weight: normal;
      }

      label {
        color: #2fa3af;
      }

      ::content  .selected-src-element {
        border: 3px solid #66CCFF;
        margin: 0;

        box-sizing:border-box;
        -moz-box-sizing:border-box;
        -webkit-box-sizing:border-box;
      }
      ::content  .selected-target-element {
        border: 3px solid #00FF99  ;
        margin: 0;

        box-sizing:border-box;
        -moz-box-sizing:border-box;
        -webkit-box-sizing:border-box;
      }
      
      ::content > *:not(ul) { /* selects the elements */
        min-width: 20px;
        min-height: 20px;
        /*border: 1px solid #DDD;*/
        margin: 2px;
        display: inline-block;
        position: relative;
        /* border inside */
        vertical-align: top;
      }

      /* Style above can be removed? */

      .connections {
        margin: 0px 0px 30px 30px;
      }

      .connections core-icon, .connections core-icon-button::shadow core-icon {
        height: 20px;
      }

      .connections ul {
        list-style: none;
      }

      .connections li {
        padding-left: 5px;
        /*padding: 0;*/
      }
      .connection-list {
        border: 2px solid #ddd;
        
        width: 500px;
        /*padding: 10px;*/

      }

      .wrapper {
        border: 2px solid #ddd;
        display: inline-block;
        position: relative;
        margin: 20px;
        margin-left: 60px;
      }

      .connectors-tab {
        width: 40px;
        margin-left: -40px;
        position: absolute;
        top: 0;
        text-align: center;
      }

      .wrapper li {
        list-style: none;
        position: relative;
        font-size: 9px;
        margin: 2px auto;
      }


      .inputMarker {
        width: 24px;
        height: 24px;
        border: 3px solid #ddd;
        border-radius: 12px;
        box-sizing: border-box;
      }

      .outputMarker {
        width: 24px;
        height: 24px;
        border: 3px solid #ddd;
        border-radius: 12px;
        box-sizing: border-box;
      }

      .wrapper label{
        position: absolute;
        top: -20px;
        left: 0;
        padding: 0;
        overflow: visible;
      }

    </style>
    <div class="connectors">
    </div>



<!--     <core-collapse id="ctrl_collapse">
      <div class="panel">
        <h3>Connection Panel</h3>
        <div class="from selector">
          <label for="src_component">From:</label>
          <core-selector id="src_component">
            <template repeat="{{el in elements}}">
              <div class="item">{{el.name}}<template if="{{el.element.id}}">#{{el.element.id}}</template></div>
            </template>

          </core-selector>
          <label for="src_attrs">Attributes:</label>
          <core-selector id="src_attrs">
            <template repeat="{{attr in _srcAttrs}}">
              <div class="item">{{attr}}</div>
            </template>

          </core-selector>
        </div>
        <div class="to selector">
          <label for="target_component">To:</label>
          <core-selector id="target_component">
            <template repeat="{{el in elements}}">
              <div class="item">{{el.name}}<template if="{{el.element.id}}">#{{el.element.id}}</template></div>
            </template>

          </core-selector>
          <label for="target_attrs">Attributes:</label>
          <core-selector id="target_attrs">
            <template repeat="{{attr in _targetAttrs}}">
              <div class="item">{{attr}}</div>
            </template>

          </core-selector>
        </div>      
        <input type="button" id="connect" value="connect" style="{{(_srcPropertySelection && _targetPropertySelection) ? 'display: block' : ''}}"></input>
        <div class="connections">
            <label>connections: </label>
            <ul>
            <template repeat="{{connection, index in _connections}}">
              <li class="connection">{{connection.sourceEl}}->{{connection.sourceProperty}} => 
                      {{connection.targetEl}}->{{connection.targetProperty}}
                       <a href="javascript:void(0)" class="del" data-index="{{index}}" on-click={{_deleteConnectionHandler}}>delete</a></li>
            </template>
            </ul>
        </div>

      </div>
  </core-collapse> -->



    
    <div id="container" on-dragover="{{allowDrop}}" on-drop="{{droppedInContainer}}">
      
      <!-- Connections -->
      <div class="connections">
        <span class="elTitle">Connections</span>
        <core-icon-button icon="view-list" on-click="{{showControls}}"></core-icon-button>
        <core-collapse id="ctrl_collapse">
            <div class="connection-list">
              <ul>
                <template if="{{!connections || connections.length < 1}}"> 
                  <li>No connections. To make a connection, drag the bubble of one component over another.</li> 
                </template>

                <template repeat="{{connection, index in connections}}">  
                  <li class="connection">
                    <core-icon icon="check-circle-blank" style="color:{{connection.source.color}};"></core-icon>
                    {{connection.source.name}} ({{connection.sourceAttr}}) 
                    <core-icon icon="arrow-forward"></core-icon> 
                    {{connection.target.name}} ({{connection.targetAttr}})
                    <core-icon-button icon="delete" id="{{connection.target.name}}" on-click="{{_deleteConnectionFromList}}"></core-icon-button>
                  </li>
                </template>
              </ul>
            </div>
        </core-collapse>
      </div>

      <!-- Components and connector dots --> 
      <template repeat="{{el, index in elements}}">
        <div class="wrapper {{el.name}}" on-th-output-changed="{{showOutputAvailable}}" on-th-input-changed="{{showInputAvailable}}" draggable="true">
          <label>{{el.name}}</label>
          
          <div id="connectors" class="connectors-tab" >
            <!-- Input -->
            <template if="{{el.element.publish | checkForInputAttr}}">
              <li class="{{el.name}} inputMarker" on-dragover="{{dragOver}}" on-dragStart="{{dragStart}}" on-dragleave="{{dragLeave}}" on-drop="{{connectBubble}}" style="background-color: {{el.inputConnectedTo ? el.inputConnectedTo.color : el.inputReady ? defaultColor : 'none'}}; border-color:{{el.inputConnectedTo ? el.inputConnectedTo.color : defaultColor}};" draggable="true"></li>
              <li>Input</li>
            </template>

            <!-- Output -->
            <template if="{{el.element.publish | checkForOutputAttr}}">
              <li id="{{index}}"  class="{{el.name}} outputMarker" on-dragStart="{{dragStart}}" on-drag="{{drag}}" on-dragEnd="{{dragEnd}}"  draggable="true" style="border-color: {{el.outputReady ? el.color : defaultColor}}"></li>
              <li>Output</li>
            </template>
          </div>
          <content select="{{el.name}}"></content>
        </div>
      </template>
    </div>
  </template>

  <script>

      Polymer('th-connector', {
        elements: [],
        _srcAttrs: [],
        _targetAttrs: [],
        _srcElementSelection: null,
        _srcPropertySelection: null,
        _targetElementSelection: null,
        _targetPropertySelection: null,
        _connections: [],

        domReady: function() {
          var self = this;

          // Set colors
          self.defaultColor = '#ddd';
          self.colors = self.getThemeColors();

          self._updateFields();
          self.watchMutation();


          // self.$.src_component.addEventListener('core-select', function() {
          //   if(!this.selection) {
          //     return;
          //   }
          //   var prev = self.querySelector('.selected-src-element')
          //   if(prev) {
          //     prev.classList.remove('selected-src-element');
          //   }
          //   self.querySelector(this.selection.textContent).classList.add('selected-src-element');
          //   self._srcElementSelection = this.selection.textContent;
          //   self._srcAttrs = self._displayFields(this);
          //   self._srcPropertySelection = null;

          // });

          // self.$.src_attrs.addEventListener('core-select', function() {
          //   if(!this.selection) {
          //     return;
          //   }
          //   self._srcPropertySelection = this.selection.textContent;

          // });

          // self.$.target_component.addEventListener('core-select', function() {
          //   if(!this.selection) {
          //     return;
          //   }
          //   self._targetElementSelection = this.selection.textContent;
          //   var prev = self.querySelector('.selected-target-element')
          //   if(prev) {
          //     prev.classList.remove('selected-target-element');
          //   }
          //   self.querySelector(this.selection.textContent).classList.add('selected-target-element');
          //   self._targetAttrs = self._displayFields(this);
          //   self._targetPropertySelection = null;

          // });

          // self.$.target_attrs.addEventListener('core-select', function() {
          //   if(!this.selection) {
          //     return;
          //   }
          //   self._targetPropertySelection = this.selection.textContent;

          // });

          // self.$.connect.addEventListener('click', function() {
          //   self.connectAttributes(self._srcElementSelection, self._srcPropertySelection,
          //                        self._targetElementSelection, self._targetPropertySelection);
          // });


        },
        _updateFields: function() {
          var self = this;
          var boringTags = ['div','ul','li','span','th-editor','br'];

          self.elements = [];

          var components = self.querySelectorAll('*'); 
          [].forEach.call(components, function(el) {
              el.setAttribute('draggable',true); // Does this do anything?
              el.addEventListener('dragstart',function(e) {
                self.fromEl = e.toElement;
              });
              // el.addEventListener('drop',function(e) {
              //   this.position = "absolute";
              //   alert();
              //   // console.log(e);
              // });
              var index=boringTags.indexOf(el.tagName.toLowerCase());
              if(index<0) {
                // self.elements.push(el);
                self.elements.push({  element: el, 
                                      name: el.tagName.toLowerCase(), 
                                      outputReady: false,
                                      inputReady: false
                                  });
              }
          
          });

          for (var i=0; i<self.elements.length; i++){
            self.elements[i].color = self.colors.accents[i];

          }

        },

        _displayFields: function(selector) {
          var self = this;
          var elSelector = selector.selection.textContent;
          var el = self.querySelector(elSelector);
          if(!el) {
            return;
          }
          var metadata = (typeof el.getMetaData === 'function') ? el.getMetaData : null; 

                   
          var attrs = el.publish;
          var attrsObj = [];
          for(key in attrs) {
            attrsObj.push(key);

          }
          return attrsObj;
          
        },
        updateConnections: function(){
          var self = this;
          self.connections = self.elements.filter(function(el){ return el.inputConnectedTo}).map(function(el){
              return { 
                target: el,
                targetAttr: 'input',
                source: el.inputConnectedTo,
                sourceAttr: 'output'
              }
          })
        },

        connectAttributes: function(source, sourceField, target, targetField) {
          console.log("connect attributes");
          var self = this;

          // check if source/target are dom element or query selector string:
          var sourceEl = (typeof source === "string") ? self.querySelector(source) : source;
          var targetEl = (typeof target === "string") ? self.querySelector(target): target;

          if (sourceEl === targetEl){ //if a bubble was dropped on itself
            alert('You cannot make a connection within the same element');
          } else { 
            
            // select the source and target el in the elements array
            var source = self.elements.filter(function(el){
              return el.element == sourceEl;
            })[0];

            var target = self.elements.filter(function(el){
              return el.element == targetEl;
            })[0];

            // make the connection in the elements array
            target.inputConnectedTo = source;
            
            var observer = new PathObserver(source.element, sourceField);
     
                 observer.open(function(newValue, oldValue) {
                 targetEl[targetField] = newValue;
                 
            });

            // to set the value when elements are connected
            target.element[targetField] = source.element[sourceField];  



            self._connections.push({
              // sourceEl: (typeof source === "string") ? source : source.tagName+(source.id ? '#'+source.id : ''),
              sourceEl: source.name + (source.element.id ? source.element.id : ''),
              sourceProperty: sourceField,
              targetEl: target.name + (target.element.id ? target.element.id : ''),
              // targetEl: (typeof target === "string") ? target : target.tagName+(target.id ? '#'+target.id : ''),
              targetProperty: targetField,
              observer: observer
           });
          }
          self.updateConnections();
          console.log(self.elements);

        },
        _deleteConnectionFromList: function(e, detail, selection){
          var self = this,
              targetEl = self.findElByName(selection.id);
          
          self._deleteConnection(targetEl);

        },
        _deleteConnectionFromBubble: function(e, detail, selection){
          var self = this;
          
          // Select the element being dragged from elements array          
          var targetEl = self.findElByName(self.fromEl.classList[0]);

          // Check if the element is not the container and if it has a connection, then ask user to remove it
          if (targetEl.inputConnectedTo ){
            self._deleteConnection(targetEl);
          }
        },
        _deleteConnection: function(targetEl){
          var self = this;
          if (confirm('Do you want to remove this connection?')) {
              targetEl.element.input = null; // TODO: switch to called clearData on the element
              targetEl.inputConnectedTo = false;
          } 
          self.updateConnections();
        },
        showControls: function(e) {
          console.log("show controls");
          this.$.ctrl_collapse.toggle();
        } ,

        watchMutation: function() {
          console.log("watch mutation");
            var change = function() {

              this._updateFields();

              this.onMutation(this, change);
            }.bind(this);


            this.onMutation(this, change);


          },
        checkForInputAttr: function(value){

          return Object.keys(value).indexOf("input") > -1 ? true : false;
        },
        checkForOutputAttr: function(value){
          // console.log(Object.keys(value));
          return Object.keys(value).indexOf("output") > -1 ? true : false;
        },
        dragStart: function(e, detail, selection){
          this.fromEl = selection;
          
          // selection.style.border = "3px solid "+this.colors.accents[selection.id];
        },
        drag: function(e, detail, selection){
          // console.log(e);
        },
        dragEnd: function(e, detail, selection){
          // console.log(e);
        },
        dragOver: function(e, detail, selection){
          selection.style.border = "3px solid "+this.colors.accents[this.fromEl.id];  
          event.preventDefault(); // allows drop event on this element

        },
        allowDrop: function(e,detail,selection){
         
          event.preventDefault(); // allows drop event on this element
        },
        dragLeave: function(e, detail, selection){
          selection.style.border = "3px solid "+this.defaultColor;
        },
        droppedInContainer: function(e, detail, selection){
          var self = this;
          
          if(self.fromEl.classList.contains("inputMarker")){
            self._deleteConnectionFromBubble(e, detail, selection);
          }else if (self.fromEl.tagName != 'LI'){
            // It's probably a component that got drag/dropped. Do something here.
          }
        },
        connectBubble: function(e, detail, selection){ //TODO: rename to be specific to circles filling up to show conenction
          console.log("drop");
          // TODO: 
          selection.style.border = "3px solid "+this.colors.accents[this.fromEl.id];
          // selection.style.backgroundColor = this.colors.accents[this.fromEl.id];
          this.connectAttributes(this.fromEl.classList[0],'output',selection.classList[0],'input');
          
        },
        getThemeColors: function(){
          var colors = {};
          colors.theme = window.CoreStyle.g.theme;
          colors.accents = [];

          for (var color in colors.theme){
            if(/^accent/.test(color)){
              colors.accents.push(colors.theme[color]);
            }
          }
          var newAccents = colors.accents.map(function(color){
        
            var color = color,
                lum = 0.3, // represents % lighter or darker (negative values are darker)
                hex = "#", c, i;
            
            // validate color and make it always 6 chars 
            color = String(color).replace(/[^0-9a-f]/gi, '');
            if (color.length < 6) {
              color = color[0]+color[0]+color[1]+color[1]+color[2]+color[2];
            }

            // convert color to decimal, adjust lumosity, and convert back to hex;
            for (i = 0; i < 3; i++) {
              c = parseInt(color.substr(i*2,2), 16);
              c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
              hex += ("00"+c).substr(c.length);
            }

            return hex;
            
          });

          colors.accents = colors.accents.concat(newAccents);
          
          return colors;
        },
        showOutputAvailable: function(e){
          var el = e.detail.tagName.toLowerCase(),
              output = e.detail.output,
              outputMarker = this.$.container.querySelector('li.'+el+ '.outputMarker');

          var element = this.elements.filter(function(elem){
            return elem.name == el;
          })[0];

          element.outputReady = output && output.length>0 ? true : false; 
        },
        showInputAvailable: function(e){
          var el = e.detail.tagName.toLowerCase(),
              input = e.detail.input,
              inputMarker = this.$.container.querySelector('li.'+el+ '.inputMarker');
          
          var element = this.elements.filter(function(elem){
            return elem.name == el;
          })[0];

          element.inputReady = input && input.length>0 ? true : false; 

        },
        findElByName: function(name){
          var self = this;
          element = self.elements.filter(function(el){
            return el.name === name;
          })[0];

          return element
        }
      });

  </script>
</polymer-element>
